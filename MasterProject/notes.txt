so, there may be a need for playerstates
because at least there's the info whether a player has won, lost or drawn
so playerstate either has bool hasWon, hasDrawn, hasLost or a separate data structure. i think the three bools are nicer
separate gamestate.isover? or is that implicit from the player states? if none have any of the three true, then the game is still ongoing

but also, the interfaces are nice for the code side but less so for the serialized json-side
because that stuff gets visualized and it'd be nice if that had a common ground too

on the other hand, i don't want all that do be mutable from the outside
which it would need to be if it was a separate class from gamestate
so in theory gamestate could HAVE that data and playerstates are just interfaces? 

about json
https://learn.microsoft.com/en-us/dotnet/standard/serialization/system-text-json/how-to?pivots=dotnet-6-0
stuff can be awaited
utf-8 serialization is a bit faster and gives a byte-array directly
public { get; set; } gets serialized automatically
otherwise there's [JsonInclude]
generics work just fine BUT
either the parameters in the constructor must have the same name as the fields they map to (but not all fields must be present)
OR i can only have a parameterless constructor

tic tac toe ais
- random
- choose line, when that fails, fall back to random
- choose line, when that fails, choose a different line, fall back to random if none possible
- alpha beta minmaxer (ignore symmetries for now) (there should only be 9! possibilities, which isn't that much... 362880...)
- "optimal" manually programmed strategy (should be fairly simple, right?)
- human, with a nice console print of the board and possible moves and console.readline input

where is the border from all the generic stuff that only works in c# to the fairly straightforward classes that can be exported to json
what even needs to be exported

when the game asks an agent to decide on a move, await that with a timeout just to ensure the program doesn't crash

for games, be able to specify a console-output-verbosity-level
- none
- finish
- roundwise (new round, finished)
- debug

each match
- an id
- a timecode 
	-> can i decode the output of System.DateTime.Now.ToBinary() in javascript?
	-> https://stackoverflow.com/questions/64698870/comparing-the-binary-representation-of-datetime-in-c-sharp
		ticks is easier
- every gamestate until the end
- of course the agents who played (ids)

agents
- an id
- custom data (for neural agents maybe)
- how does elo ranking work?
	-> https://en.wikipedia.org/wiki/Elo_rating_system
	-> by taking the opponent's current scores and doing stuff with that
	-> IMPORTANT: when doing ranked matches, a given agent-id can only be in one game at any given time!
		-> so when doing a tournament, that'll be interesting

does the current way of doing it with each gamestate having a current player work with godfield?
because of the percentage weapons
say it's a 25% weapon
and say it's a 4 player round with players A, B, C and D
so player A plays it
now there's a 25% chance B will get hit and will have to defend which then leads to further gamestates
and there's a 75% chance that B will not be hit
which means a 25% chance for C to get hit, which has the overall likelihood from the initial move of 18.75%
which leaves 56.25% that B and C will be missed
and so on
and that's a lot of possibilities and quite annoying to calculate
and it'd be easier if each step could just be the two possibilities hit or miss
now, there are two options
a) an invalid player index and game knows what to do with that
b) an empty set of moves or a "do nothing" move which gets applied to the gamestate which is cleaner
   so if game gets just one move, it'll auto-apply that. that sounds good.
   only if there's a choice will the agent be asked
   anything else is a move by default
   and that means the gamestate can even give null as a move
   nobody will question it other than the gamestate itself
